import { JWTPayload } from '#/generators/auth.js';
import { Person } from '#/generators/demo/persons.js';
import type { ICompany, IPerson, IWorkingAt } from '#/generators/demo/types.js';
import { generateMersenne53Randomizer } from '@faker-js/faker';
import type { DatasetConfig } from './config.js';
import { Company, WorkingAt } from './demo/companies.js';
import { createFaker } from './utils.js';

function today() {
	const d = new Date();
	d.setHours(0, 0, 0, 0);
	return d;
}

/**
 * The dataset generated by the buildDataset function. This is exported and used
 * by the mock api to serve data.
 */
export type Dataset = {
	// Example entities
	/**
	 * All companies in the dataset indexed by their ID.
	 */
	companies: Record<string, ICompany>;

	/**
	 * All persons in the dataset indexed by their ID.
	 */
	persons: Record<string, IPerson>;

	/**
	 * All working at relationships in the dataset indexed by their person ID.
	 */
	workingAt: IWorkingAt[];

	/**
	 * All tokens in the dataset indexed by their login id.
	 */
	tokens: Record<string, JWTPayload>;
};

/**
 * Indexes for the dataset. These are used to speed up queries.
 * They can be used without performance penalty by the mock api, but should not be exported to JSON
 * since it is redundant data.
 */
export type DatasetIndexes = {
	workingAtIndexedByPersonId: Record<string, IWorkingAt>;
	workingAtIndexedByCompanyId: Record<string, IWorkingAt[]>;
};

/**
 * This method generates a complete dataset based on the provided configuration.
 * @param config - The configuration for the dataset.
 * @returns The generated dataset.
 */
export function buildDataset(config: DatasetConfig) {
	// Create a randomizer or use the provided one.
	const randomizer = config.randomizer ?? generateMersenne53Randomizer();

	// Seed the randomizer if a seed is provided to get deterministic results.
	if (config.seed != null) {
		randomizer.seed(config.seed + 1);
	}

	// Create a faker instance with the randomizer and refDate.
	// The refDate is used to generate data that is relative to a specific date.
	// If no refDate is provided, the current date is used.
	const refDate = config.refDate ?? today();
	const faker = createFaker({ randomizer, refDate });

	// Create a unique enforcer to ensure unique ids.
	// const uniqueEnforcer = new UniqueEnforcer();

	/*
		Generate a demo dataset. This code can be deleted
		and replaced with your own data generation logic.
	*/

	// Generate companies
	const companies: Record<string, ICompany> = {};
	// The first company is our main company. We pass it a name so we can identify it.
	companies.acme = Company({
		faker,
		refDate,
		id: 'acme',
		name: 'ACME Inc.',
	});

	// The remaining companies are generated by the Company generator.
	// The iterator starts at 1 because we already created the main company.
	for (let i = 1; i < config.companyCount; i++) {
		const company = Company({
			faker,
			refDate,
		});
		companies[company.id] = company;
	}

	// Generate persons
	const persons: Record<string, IPerson> = {};
	// We need an admin user, so we create it first.
	persons.admin = Person({
		faker,
		id: 'admin',
	});

	// The remaining persons are generated by the Person generator.
	// The iterator starts at 1 because we already created the admin user.
	for (let i = 1; i < config.personCount; i++) {
		const person = Person({
			faker,
		});
		persons[person.id] = person;
	}

	// Generate working at relationships
	const workingAt: IWorkingAt[] = [];
	const { admin, ...otherPersons } = persons;
	// Our admin user works at the main company.
	workingAt.push({ personId: admin.id, companyId: companies.acme.id, role: 'admin' });
	// The remaining persons are assigned to a random company.
	for (const person of Object.values(otherPersons)) {
		const company = faker.helpers.objectValue(companies);
		workingAt.push(WorkingAt({ faker, personId: person.id, companyId: company.id }));
	}
	// Make sure we also have at least one manager and one employee.
	if (workingAt[1] != null) workingAt[1].role = 'manager';
	if (workingAt[2] != null) workingAt[2].role = 'employee';

	// Index the working at relationships by person id for further processing.
	// To make the example easier, a person can only work at one company.
	const workingAtIndexedByPersonId = Object.fromEntries(workingAt.map(e => [e.personId, e]));
	// A company can have multiple persons working at it.
	const workingAtIndexedByCompanyId = Object.groupBy(workingAt, e => e.companyId) as Record<
		string,
		IWorkingAt[]
	>;

	// Create Login tokens for the admin user, a manager and an employee.
	const tokens: Record<string, JWTPayload> = {};
	tokens.admin = JWTPayload({ person: admin, company: companies.acme, role: 'admin' });
	const manager = workingAt.find(e => e.role === 'manager');
	const employee = workingAt.find(e => e.role === 'employee');
	if (manager != null)
		tokens.manager = JWTPayload({
			person: persons[manager.personId]!,
			company: companies[manager.companyId]!,
			role: manager.role,
		});
	if (employee != null)
		tokens.employee = JWTPayload({
			person: persons[employee.personId]!,
			company: companies[employee.companyId]!,
			role: employee.role,
		});

	const data: Dataset = {
		companies,
		persons,
		workingAt,
		tokens,
	};

	const indexes: DatasetIndexes = {
		workingAtIndexedByPersonId,
		workingAtIndexedByCompanyId,
	};

	/*
		END CUSTOM DATA GENERATION
	*/

	return {
		randomizer,
		faker,
		data,
		indexes,
	};
}
